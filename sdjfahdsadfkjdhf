Why Chaos Daemon Runs on Each Node
Node-Level Fault Injection:
Chaos Mesh is designed to simulate failures (e.g., network latency, process kills, resource exhaustion, container crashes) that affect individual nodes or the workloads running on them.
To achieve this, the Chaos Daemon needs to operate locally on each node to manipulate its network stack, processes, resources, or container runtime. Running on every node ensures it can apply chaos wherever it’s needed in the cluster.
DaemonSet Design:
In Kubernetes, a DaemonSet automatically deploys a pod to every node in the cluster (or a matching subset). The Chaos Daemon is defined as a DaemonSet in the Chaos Mesh manifests (e.g., generated by install.sh or Helm charts), ensuring pervasive coverage.

Distributed Chaos Control:
The Chaos Controller Manager (another Chaos Mesh component) orchestrates chaos experiments and sends instructions to the Chaos Daemon instances via gRPC. Having a Daemon on each node allows localized execution of these instructions, avoiding the need for remote node access and ensuring low-latency, reliable fault injection.
How Permissions Support Running on Each Node
The permissions we’ve discussed—whether privileged: true or the capability-based approach (NET_ADMIN, CAP_SYS_PTRACE, CAP_SYS_RESOURCE, CAP_KILL)—enable the Chaos Daemon to perform its tasks on each node. Here’s how they tie into its node-wide deployment:
Security Context (Capabilities):
With:
yaml

Collapse

Wrap

Copy
securityContext:
  capabilities:
    add: ["NET_ADMIN", "CAP_SYS_PTRACE", "CAP_SYS_RESOURCE", "CAP_KILL"]
Purpose: These capabilities allow the Daemon to:
Manipulate the network on each node (NET_ADMIN).
Kill or trace processes on each node (CAP_SYS_PTRACE, CAP_KILL).
Stress resources on each node (CAP_SYS_RESOURCE).
Each Chaos Daemon instance applies these permissions locally to its host node.
Host Namespace Access:
With:
yaml

Collapse

Wrap

Copy
spec:
  hostPID: true
  hostNetwork: true
Purpose: Ensures the Daemon can access the host’s process table (hostPID) and network stack (hostNetwork) on each node it runs on. This is necessary for node-specific chaos (e.g., killing a process on Node A or delaying traffic on Node B).

Minimized Capabilities:
Using NET_ADMIN, CAP_SYS_PTRACE, CAP_SYS_RESOURCE, CAP_KILL instead of privileged: true ensures each Daemon instance has only the permissions it needs, reducing the risk on every node.
Test this across nodes to confirm all chaos types work (e.g., network chaos on Node 1, process chaos on Node 2).
Conditional Host Access:
Enable hostPID or hostNetwork only on nodes where specific chaos types are active. This requires dynamic configuration (e.g., via Chaos Mesh experiment specs or custom DaemonSet management), as a static DaemonSet applies the same spec everywhere.
Runtime Security:
Adding readOnlyRootFilesystem: true and dropping unnecessary capabilities (drop: ["ALL"]) hardens each Daemon instance, protecting all nodes from persistence attacks.
Node Restriction:
