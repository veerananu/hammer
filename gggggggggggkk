What We Changed
yaml
Copy
# application.yml - Added one line:
spring:
  threads:
    virtual:
      enabled: true
Environment
Java Version: 17 → 21
Platform: OpenShift
Framework: Spring Boot
Database: JDBC (blocking calls)
Problem & Solution Summary
Problem
High CPU usage (80-90%)
Each request makes 100 database calls
Platform threads causing excessive context switching
Solution
Enabled virtual threads with single configuration
No code changes required
CPU usage dropped to 30-40%
Key Performance Metrics
Metric	Before	After	Improvement
CPU Usage	80-90%	30-40%	~55% reduction
Memory (threads)	100MB per 100 threads	100KB per 100 threads	99% reduction
Concurrent Requests	50-100	500+	5-10x increase
Response Time (P95)	3000ms	800ms	73% faster
Technical Explanation
Platform Threads vs Virtual Threads
Platform Threads (1:1)

Each Java thread = 1 OS thread
1MB memory per thread
OS manages scheduling
Limited by OS resources
Virtual Threads (M:N)

Many virtual threads → Few OS threads
1KB memory per virtual thread
JVM manages scheduling
Can create millions
Why It Helps Database Calls
java
Copy
// 100 DB calls block 100 platform threads (expensive)
// vs
// 100 DB calls on virtual threads (cheap, carrier threads reused)
Implementation Steps
Update Java version to 21
dockerfile
Copy
FROM openjdk:21-jdk-slim
Add configuration
yaml
Copy
spring:
  threads:
    virtual:
      enabled: true
Deploy and verify
java
Copy
// Check if working
Thread.currentThread().isVirtual() // Should return true
Verification Commands
bash
Copy
# Check CPU usage
oc adm top pods

# Verify virtual threads active
oc exec <pod> -- jstack $(pgrep java) | grep -c "VirtualThread"

# Monitor logs
oc logs <pod> | grep -i virtual
Important Notes
What Virtual Threads Do
✅ Reduce CPU context switching
✅ Handle blocking I/O efficiently
✅ Allow more concurrent requests
✅ Reduce memory footprint
What They Don't Do
❌ Don't make database queries faster
❌ Don't reduce database load
❌ Don't help with CPU-intensive tasks
❌ Don't work with synchronized blocks (pinning)
Monitoring Points
CPU Usage: Should decrease significantly
Thread Count: Will show many virtual threads
Response Time: Should improve under load
Memory: Thread memory usage should decrease
Rollback Plan
If issues occur:

yaml
Copy
# Remove or set to false
spring:
  threads:
    virtual:
      enabled: false
Redeploy with Java 21 (virtual threads disabled) or Java 17

Best Practices
Database Connection Pool: May need to increase pool size
yaml
Copy
spring:
  datasource:
    hikari:
      maximum-pool-size: 100  # Increase if needed
Avoid Synchronized Blocks: Can cause thread pinning
java
Copy
// Avoid
synchronized(lock) { ... }

// Prefer
ReentrantLock lock = new ReentrantLock();
Monitor After Deployment: Watch for first 24-48 hours
Common Issues & Solutions
Issue	Cause	Solution
Virtual threads not working	Config not applied	Verify spring.threads.virtual.enabled=true
Still high CPU	Thread pinning	Check for synchronized blocks
Database errors	Connection pool exhausted	Increase pool size
Not seeing improvement	Not enough blocking I/O	Virtual threads help mainly with I/O
Team Knowledge Transfer
Key Concepts to Understand
Virtual threads are cheap - Can create thousands
Blocking I/O doesn't block OS thread - Carrier thread is released
No code changes needed - Spring handles everything
M:N mapping - Many virtual threads use few OS threads
